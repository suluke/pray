\section{Einleitung und Problembeschreibung}

%TODO z.B. Ziele der Implementierung: Compile-Time Flexbilität

Dieses Jahr bestand die Aufgabe des Multikern-Praktikums darin einen Raytracer zu entwickeln, der gegebene Szenen rendert und als Bitmap-Bild ausgibt.
Damit diese Aufgabe vom Umfang innerhalb der zeitlichen Grenzen des Praktikums bleibt wurden einige Einschränkungen vorgenommen.
In der ersten Phase des Praktikums ging es lediglich darum einen Whitted-Style-Raytracer für Szenen mit komplett-diffusen Materialien zu implementieren.
Auch die Menge an geometrischen Primitiven wurde auf Dreiecke reduziert.

Da uns bewusst war, dass in einem späteren zweiten Teil die Aufgabenstellung erweitert würde, achteten wir darauf, dass unsere Implementierung möglichst flexibel und erweiterbar ist.
Eine bewusste Entscheidung war auch, jede Technik zur Beschleunigung so zu integrieren, dass wir sie optional zur Compilezeit zu- bzw abschalten konnten.
Dies ermöglichte uns, die Auswirkungen von konkreten Techniken und deren Zusammenspiel bezogen auf die Ausführungsgeschwindigkeit jederzeit zu überprüfen, um schlussendlich eine möglichst optimale Konfiguration zu erzielen.

Der Zweite Teil der Implementierungsphase war den Raytracer um ein weiteres Tracing-Verfahren, nämlich Pathtracing, zu ergänzen.
Im ersten Abschnitt der Implementierungsphase hatten wir zunächst darauf verzichtet, die GPU als Beschleuniger einzusetzen, da unsere CPU-Lösung bereits sehr gute Ergebnisse erziehlte.
Unter anderem lag dies daran, dass wir unseren Code bereits manuell parallelisiert und vektorisiert, d.h. mittels Instruktionen aus den Befehlssatzerweiterungen SSE bzw. AVX ausgedrückt hatten.
Jedoch wurde uns in Phase zwei bewusst, dass die zusätzliche Rechenleistung hinsichtlich des exponentiell wachsenden Rechenaufwands, der beim Pathtracing entsteht, unverzichtbar ist. 
Deshalb wurde im zweiten Abschnitt die Pathtracing-Komponente sowohl für die CPU als auch mit CUDA für die GPU umgesetzt.

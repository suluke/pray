\section{Optimierungen}
Zusätzlich zu den großen Parallelisierungsmöglichkeiten (OpenMP/C++Threads, CUDA, SSE/AVX, Datenstrukturen), haben wir uns überlegt wo es noch möglich wäre einen eventuell auch kleinen Zeitgewinn hinauszuholen.
Hierfür haben wir durch Analyse erst einmal versucht kritische Abschnitte in unserer Pipeline zu finden.
Dies wurde zum Teil durch Benchmarking verschiedener Komponenten via Zeitmessung der Laufzeit intern oder durch unser Benchmarking-Tool und auch durch eine Call-Analyse mit Callgrind.
Kleinere Optimierungen umfassen beispielsweise das Cachen des Inversen der Richtung eines Strahls, da Divisionen insbesondere bei SSE/AVX sehr zeitaufwändig sind.

\subsection{Identifikation kritischer Abschnitte}
Kritische Abschnitte im Code wurden hauptsächlich durche eine von zwei Verfahren gefunden und optimiert.
\begin{enumerate}
	\item Analyse mit Callgrind zum finden von Hot-Paths. Händische Analyse der Wichtigen Funktionen im Hot-Path.
	\item Benchmarking von verschiedenen Einstellungen und Parametern um eine optimale Belegung zu bestimmen.
\end{enumerate}
Mithilfe dieser Informationen wurden dann Anpassungen vorgenommen um die Performance zu verbessern.
Dann wiederholte sich der erste Schritt natürlich von vorne.
\subsubsection{Profiler}

\subsection{Heuristiken}
Wenige Dreiecke -> DummyAcceleration
Stackgröße Cuda, BIH...

\subsection{Subsampling}
Bei der Suche nach leistungssteigernden Maßnahmen haben wir uns unter anderem auch mit dem Thema Subsampling beschäftigt.
Das Cube-Beispiel bietet hierfür eine ideale Motivation, da über sehr große Bereiche nur der Hintergrund zu sehen ist, und man lediglich am Würfel selber alle Details abtasten möchte.
Zusätzlich kommt hinzu, dass bei strukturierten Bilden auf Basis von Dreiecken regionenbasierend Farben sehr ähnlich sind.
In unserem Raytracer stehen daher zur Compilezeit drei verschiedene Abtaststrategien zur Auswahl, die im folgenden näher beschrieben werden.

\subsubsection{Normales Sampling}
Zunächst haben wir nur das normale Abtasten der Szene mit je einem Strahl pro Ausgabebildpixel implementiert.
Hierzu gibt es abgesehen von der Parallelisierung des Ray-Castings mit OpenMP und dem Umgang mit verschiedenen Strahlengrößen nichts weiteres zu erwähnen.

\subsubsection{Interpolierendes Sampling}
Ein erstes naives Vorgehen um die Menge an verschossenen Strahlen bei gleicher Bildgröße zu verringern haben wir im "`interpolierenden Sampler"' implementiert.
Wir haben uns dafür entschieden, die Szene in einem Schachbrettmuster abzutasten, also nur jeden zweiten Primärstrahl zu verschießen.
Anschließend werden die Lücken durch Interpolation aus den bis zu vier verschossenen Nachbarpixeln gefüllt (ohne schräg angrenzende Nachbarn).
Die Ränder stellen hierbei ein Problem dar, da ihnen (insbesondere bei Ecken) bis zu zwei tatsächlich abgetastete Nachbarpixel fehlen.
In der ersten Lösung hatten wir deshalb alle Randpixel normal gesampelt und nur Nicht-Randpixel interpoliert.
Die Interpolation wird außerdem naiv durchgeführt, also lediglich ein Mittelwert aus den angrenzenden Pixeln berechnet, um den interpolierten Farbwert zu erhalten.
Gerade an Kanten führt dies zu sägezahmusterartigen Artefakten.
Der interpolierende Sampler sorgt in der Praxis praktisch für eine Verdoppelung der Geschwindigkeit, was natürlich dadurch zustandekommt, dass nur die Hälfte der Arbeit auch wirklich vollbracht wird.
Dies ist durchaus als Schummelei zu werten, weswegen wir den interpolierenden Sampler auch niemals während der Benchmarks aktiviert hatten.

\subsubsection{Adaptives Sampling}
Obwohl weniger Arbeit verrichten, also Subsampling im Allgemeinen, wie bereits erwähnt definitiv nicht pauschal legal sein sollte, kann man aus unserer Sicht aber trotzdem argumentieren, dass es unter bestimmten Umständen doch legitim sein kann.
Unsere Raytracer haben nicht den Anspruch, Pixel-perfekte Ergebnisse zu liefern.
Insbesondere sorgen Fließkommaungenauigkeiten immer wieder dafür, dass Strahlen fälschlicherweise durch den (theoretisch nicht existenten) Spalt zwischen zwei Dreiecken durchschießen und die Szene so verlassen.
Unserer Ansicht nach ist es also legitim, bestimmte Sichtstrahlen zu überspringen, solange aktiv versucht wird zu vermeiden, dass relevante Bildinformation durch Unterabtastung verloren geht.
Deshalb haben wir zusätzlich auch noch einen adaptiven Sampler implementiert, der erst ein Schachbrettmuster verschießt (Bei SSE-Unterstützung sogar als große Sparse Rays) und für Regionen bei denen die Pixel eine zu große Ungenauigkeit untereinander aufweisen, das inverse Raypaket noch einmal zu verschießen.
